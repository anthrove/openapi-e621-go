/*
E621

OpenAPI definition for E621's API. You can find the source [here](https://github.com/DonovanDMC/E621OpenAPI)<br> This document is intended to compliment E621's existing [API Documentation](https://e621.net/help/api).<br> Note if E621's api is under attack and/or cloudflare protections are enabled, the \"Try it out\" buttons here will not work.<br> If they are not working, you can check this [Unofficial Status Page](https://status.e621.ws).

API version: d69c34e
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// PostsAPIService PostsAPI service
type PostsAPIService service

type PostsAPIApprovePostRequest struct {
	ctx        context.Context
	ApiService *PostsAPIService
	postId     *int32
}

func (r PostsAPIApprovePostRequest) PostId(postId int32) PostsAPIApprovePostRequest {
	r.postId = &postId
	return r
}

func (r PostsAPIApprovePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApprovePostExecute(r)
}

/*
ApprovePost Approve Post

You must have the "Approve Posts" permission.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PostsAPIApprovePostRequest
*/
func (a *PostsAPIService) ApprovePost(ctx context.Context) PostsAPIApprovePostRequest {
	return PostsAPIApprovePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PostsAPIService) ApprovePostExecute(r PostsAPIApprovePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.ApprovePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/moderator/post/approval.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postId == nil {
		return nil, reportError("postId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "post_id", r.postId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PostsAPICopyNotesToPostRequest struct {
	ctx                    context.Context
	ApiService             *PostsAPIService
	id                     int32
	copyNotesToPostRequest *CopyNotesToPostRequest
}

func (r PostsAPICopyNotesToPostRequest) CopyNotesToPostRequest(copyNotesToPostRequest CopyNotesToPostRequest) PostsAPICopyNotesToPostRequest {
	r.copyNotesToPostRequest = &copyNotesToPostRequest
	return r
}

func (r PostsAPICopyNotesToPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CopyNotesToPostExecute(r)
}

/*
CopyNotesToPost Copy Notes To Post

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the post.
	@return PostsAPICopyNotesToPostRequest
*/
func (a *PostsAPIService) CopyNotesToPost(ctx context.Context, id int32) PostsAPICopyNotesToPostRequest {
	return PostsAPICopyNotesToPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PostsAPIService) CopyNotesToPostExecute(r PostsAPICopyNotesToPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.CopyNotesToPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/posts/{id}/copy_notes.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.copyNotesToPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PostsAPIDeletePostRequest struct {
	ctx           context.Context
	ApiService    *PostsAPIService
	id            int32
	reason        *string
	moveFavorites *bool
	copySources   *bool
	copyTags      *bool
	commit        *string
}

// If the post does not have an active flag, this is required.
func (r PostsAPIDeletePostRequest) Reason(reason string) PostsAPIDeletePostRequest {
	r.reason = &reason
	return r
}

// Move favorites to parent.
func (r PostsAPIDeletePostRequest) MoveFavorites(moveFavorites bool) PostsAPIDeletePostRequest {
	r.moveFavorites = &moveFavorites
	return r
}

// Copy sources to parent.
func (r PostsAPIDeletePostRequest) CopySources(copySources bool) PostsAPIDeletePostRequest {
	r.copySources = &copySources
	return r
}

// Copy tags to parent.
func (r PostsAPIDeletePostRequest) CopyTags(copyTags bool) PostsAPIDeletePostRequest {
	r.copyTags = &copyTags
	return r
}

// If not set, nothing will happen.
func (r PostsAPIDeletePostRequest) Commit(commit string) PostsAPIDeletePostRequest {
	r.commit = &commit
	return r
}

func (r PostsAPIDeletePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePostExecute(r)
}

/*
DeletePost Delete Post

You must have the "Approve Posts" permission. `commit=Delete` must be set.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the post.
	@return PostsAPIDeletePostRequest
*/
func (a *PostsAPIService) DeletePost(ctx context.Context, id int32) PostsAPIDeletePostRequest {
	return PostsAPIDeletePostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PostsAPIService) DeletePostExecute(r PostsAPIDeletePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.DeletePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/moderator/post/posts/{id}/delete.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.reason != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "reason", r.reason, "")
	}
	if r.moveFavorites != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "move_favorites", r.moveFavorites, "")
	}
	if r.copySources != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "copy_sources", r.copySources, "")
	}
	if r.copyTags != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "copy_tags", r.copyTags, "")
	}
	if r.commit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "commit", r.commit, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PostsAPIEditPostRequest struct {
	ctx                       context.Context
	ApiService                *PostsAPIService
	id                        int32
	postTagString             *string
	postOldTagString          *string
	postTagStringDiff         *string
	postSourceDiff            *string
	postSource                *string
	postOldSource             *string
	postParentId              *int32
	postOldParentId           *int32
	postDescription           *string
	postOldDescription        *string
	postRating                *Ratings
	postOldRating             *Ratings
	postEditReason            *string
	postIsRatingLocked        *bool
	postIsNoteLocked          *bool
	postBgColor               *string
	postIsCommentLocked       *bool
	postIsStatusLocked        *bool
	postLockedTags            *string
	postHideFromAnonymous     *bool
	postHideFromSearchEngines *bool
}

// Replaces all tags on the post.
func (r PostsAPIEditPostRequest) PostTagString(postTagString string) PostsAPIEditPostRequest {
	r.postTagString = &postTagString
	return r
}

// The tag string before your edits, used to reconcile conflicts.
func (r PostsAPIEditPostRequest) PostOldTagString(postOldTagString string) PostsAPIEditPostRequest {
	r.postOldTagString = &postOldTagString
	return r
}

// Tags with a minus are removed, else they are added. Mutually exclusive with tag_string.
func (r PostsAPIEditPostRequest) PostTagStringDiff(postTagStringDiff string) PostsAPIEditPostRequest {
	r.postTagStringDiff = &postTagStringDiff
	return r
}

// Sources with a minus are removed, else they are added. It is not possible to add inactive sources through this. Mutually exclusive with source.
func (r PostsAPIEditPostRequest) PostSourceDiff(postSourceDiff string) PostsAPIEditPostRequest {
	r.postSourceDiff = &postSourceDiff
	return r
}

// Replaces all sources on the post.
func (r PostsAPIEditPostRequest) PostSource(postSource string) PostsAPIEditPostRequest {
	r.postSource = &postSource
	return r
}

// The sources before your edits, used to reconcile conflicts.
func (r PostsAPIEditPostRequest) PostOldSource(postOldSource string) PostsAPIEditPostRequest {
	r.postOldSource = &postOldSource
	return r
}

func (r PostsAPIEditPostRequest) PostParentId(postParentId int32) PostsAPIEditPostRequest {
	r.postParentId = &postParentId
	return r
}

func (r PostsAPIEditPostRequest) PostOldParentId(postOldParentId int32) PostsAPIEditPostRequest {
	r.postOldParentId = &postOldParentId
	return r
}

func (r PostsAPIEditPostRequest) PostDescription(postDescription string) PostsAPIEditPostRequest {
	r.postDescription = &postDescription
	return r
}

func (r PostsAPIEditPostRequest) PostOldDescription(postOldDescription string) PostsAPIEditPostRequest {
	r.postOldDescription = &postOldDescription
	return r
}

func (r PostsAPIEditPostRequest) PostRating(postRating Ratings) PostsAPIEditPostRequest {
	r.postRating = &postRating
	return r
}

func (r PostsAPIEditPostRequest) PostOldRating(postOldRating Ratings) PostsAPIEditPostRequest {
	r.postOldRating = &postOldRating
	return r
}

func (r PostsAPIEditPostRequest) PostEditReason(postEditReason string) PostsAPIEditPostRequest {
	r.postEditReason = &postEditReason
	return r
}

// You must be Privileged+.
func (r PostsAPIEditPostRequest) PostIsRatingLocked(postIsRatingLocked bool) PostsAPIEditPostRequest {
	r.postIsRatingLocked = &postIsRatingLocked
	return r
}

// You must be Janitor+.
func (r PostsAPIEditPostRequest) PostIsNoteLocked(postIsNoteLocked bool) PostsAPIEditPostRequest {
	r.postIsNoteLocked = &postIsNoteLocked
	return r
}

// You must be Janitor+.
func (r PostsAPIEditPostRequest) PostBgColor(postBgColor string) PostsAPIEditPostRequest {
	r.postBgColor = &postBgColor
	return r
}

// You must be Admin+.
func (r PostsAPIEditPostRequest) PostIsCommentLocked(postIsCommentLocked bool) PostsAPIEditPostRequest {
	r.postIsCommentLocked = &postIsCommentLocked
	return r
}

// You must be Admin+.
func (r PostsAPIEditPostRequest) PostIsStatusLocked(postIsStatusLocked bool) PostsAPIEditPostRequest {
	r.postIsStatusLocked = &postIsStatusLocked
	return r
}

// You must be Admin+.
func (r PostsAPIEditPostRequest) PostLockedTags(postLockedTags string) PostsAPIEditPostRequest {
	r.postLockedTags = &postLockedTags
	return r
}

// You must be Admin+.
func (r PostsAPIEditPostRequest) PostHideFromAnonymous(postHideFromAnonymous bool) PostsAPIEditPostRequest {
	r.postHideFromAnonymous = &postHideFromAnonymous
	return r
}

// You must be Admin+.
func (r PostsAPIEditPostRequest) PostHideFromSearchEngines(postHideFromSearchEngines bool) PostsAPIEditPostRequest {
	r.postHideFromSearchEngines = &postHideFromSearchEngines
	return r
}

func (r PostsAPIEditPostRequest) Execute() (*Post, *http.Response, error) {
	return r.ApiService.EditPostExecute(r)
}

/*
EditPost Edit Post

Most errors are silently swallowed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the post.
	@return PostsAPIEditPostRequest
*/
func (a *PostsAPIService) EditPost(ctx context.Context, id int32) PostsAPIEditPostRequest {
	return PostsAPIEditPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Post
func (a *PostsAPIService) EditPostExecute(r PostsAPIEditPostRequest) (*Post, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Post
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.EditPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/posts/{id}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.postTagString != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[tag_string]", r.postTagString, "")
	}
	if r.postOldTagString != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[old_tag_string]", r.postOldTagString, "")
	}
	if r.postTagStringDiff != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[tag_string_diff]", r.postTagStringDiff, "")
	}
	if r.postSourceDiff != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[source_diff]", r.postSourceDiff, "")
	}
	if r.postSource != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[source]", r.postSource, "")
	}
	if r.postOldSource != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[old_source]", r.postOldSource, "")
	}
	if r.postParentId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[parent_id]", r.postParentId, "")
	}
	if r.postOldParentId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[old_parent_id]", r.postOldParentId, "")
	}
	if r.postDescription != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[description]", r.postDescription, "")
	}
	if r.postOldDescription != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[old_description]", r.postOldDescription, "")
	}
	if r.postRating != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[rating]", r.postRating, "")
	}
	if r.postOldRating != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[old_rating]", r.postOldRating, "")
	}
	if r.postEditReason != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[edit_reason]", r.postEditReason, "")
	}
	if r.postIsRatingLocked != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[is_rating_locked]", r.postIsRatingLocked, "")
	}
	if r.postIsNoteLocked != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[is_note_locked]", r.postIsNoteLocked, "")
	}
	if r.postBgColor != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[bg_colo]r", r.postBgColor, "")
	}
	if r.postIsCommentLocked != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[is_comment_locked]", r.postIsCommentLocked, "")
	}
	if r.postIsStatusLocked != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[is_status_locked]", r.postIsStatusLocked, "")
	}
	if r.postLockedTags != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[locked_tags]", r.postLockedTags, "")
	}
	if r.postHideFromAnonymous != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[hide_from_anonymous]", r.postHideFromAnonymous, "")
	}
	if r.postHideFromSearchEngines != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "post[hide_from_search_engines]", r.postHideFromSearchEngines, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PostsAPIExpungePostRequest struct {
	ctx        context.Context
	ApiService *PostsAPIService
	id         int32
	reason     *string
}

func (r PostsAPIExpungePostRequest) Reason(reason string) PostsAPIExpungePostRequest {
	r.reason = &reason
	return r
}

func (r PostsAPIExpungePostRequest) Execute() (*AddFavorite201Response, *http.Response, error) {
	return r.ApiService.ExpungePostExecute(r)
}

/*
ExpungePost Expunge Post

You must have the "Approve Posts" permission and be Admin+.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the post.
	@return PostsAPIExpungePostRequest
*/
func (a *PostsAPIService) ExpungePost(ctx context.Context, id int32) PostsAPIExpungePostRequest {
	return PostsAPIExpungePostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AddFavorite201Response
func (a *PostsAPIService) ExpungePostExecute(r PostsAPIExpungePostRequest) (*AddFavorite201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AddFavorite201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.ExpungePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/moderator/post/posts/{id}/expunge.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.reason != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "reason", r.reason, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PostsAPIGetPostRequest struct {
	ctx        context.Context
	ApiService *PostsAPIService
	id         int32
}

func (r PostsAPIGetPostRequest) Execute() (*AddFavorite201Response, *http.Response, error) {
	return r.ApiService.GetPostExecute(r)
}

/*
GetPost Get Post

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the post.
	@return PostsAPIGetPostRequest
*/
func (a *PostsAPIService) GetPost(ctx context.Context, id int32) PostsAPIGetPostRequest {
	return PostsAPIGetPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AddFavorite201Response
func (a *PostsAPIService) GetPostExecute(r PostsAPIGetPostRequest) (*AddFavorite201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AddFavorite201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.GetPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/posts/{id}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PostsAPIGetPostInSequenceRequest struct {
	ctx        context.Context
	ApiService *PostsAPIService
	id         int32
	seq        *string
}

// The direction to move in the sequence.
func (r PostsAPIGetPostInSequenceRequest) Seq(seq string) PostsAPIGetPostInSequenceRequest {
	r.seq = &seq
	return r
}

func (r PostsAPIGetPostInSequenceRequest) Execute() (*AddFavorite201Response, *http.Response, error) {
	return r.ApiService.GetPostInSequenceExecute(r)
}

/*
GetPostInSequence Get Post In Sequence

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the post.
	@return PostsAPIGetPostInSequenceRequest
*/
func (a *PostsAPIService) GetPostInSequence(ctx context.Context, id int32) PostsAPIGetPostInSequenceRequest {
	return PostsAPIGetPostInSequenceRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AddFavorite201Response
func (a *PostsAPIService) GetPostInSequenceExecute(r PostsAPIGetPostInSequenceRequest) (*AddFavorite201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AddFavorite201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.GetPostInSequence")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/posts/{id}/show_seq.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.seq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seq", r.seq, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PostsAPIGetRandomPostRequest struct {
	ctx        context.Context
	ApiService *PostsAPIService
	tags       *string
}

func (r PostsAPIGetRandomPostRequest) Tags(tags string) PostsAPIGetRandomPostRequest {
	r.tags = &tags
	return r
}

func (r PostsAPIGetRandomPostRequest) Execute() (*AddFavorite201Response, *http.Response, error) {
	return r.ApiService.GetRandomPostExecute(r)
}

/*
GetRandomPost Get Random Post

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PostsAPIGetRandomPostRequest
*/
func (a *PostsAPIService) GetRandomPost(ctx context.Context) PostsAPIGetRandomPostRequest {
	return PostsAPIGetRandomPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AddFavorite201Response
func (a *PostsAPIService) GetRandomPostExecute(r PostsAPIGetRandomPostRequest) (*AddFavorite201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AddFavorite201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.GetRandomPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/posts/random.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PostsAPIMarkPostAsTranslatedRequest struct {
	ctx                         context.Context
	ApiService                  *PostsAPIService
	id                          int32
	markPostAsTranslatedRequest *MarkPostAsTranslatedRequest
}

func (r PostsAPIMarkPostAsTranslatedRequest) MarkPostAsTranslatedRequest(markPostAsTranslatedRequest MarkPostAsTranslatedRequest) PostsAPIMarkPostAsTranslatedRequest {
	r.markPostAsTranslatedRequest = &markPostAsTranslatedRequest
	return r
}

func (r PostsAPIMarkPostAsTranslatedRequest) Execute() (*AddFavorite201Response, *http.Response, error) {
	return r.ApiService.MarkPostAsTranslatedExecute(r)
}

/*
MarkPostAsTranslated Mark Post As Translated

Will error if no body is provided.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the post.
	@return PostsAPIMarkPostAsTranslatedRequest
*/
func (a *PostsAPIService) MarkPostAsTranslated(ctx context.Context, id int32) PostsAPIMarkPostAsTranslatedRequest {
	return PostsAPIMarkPostAsTranslatedRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AddFavorite201Response
func (a *PostsAPIService) MarkPostAsTranslatedExecute(r PostsAPIMarkPostAsTranslatedRequest) (*AddFavorite201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AddFavorite201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.MarkPostAsTranslated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/posts/{id}/mark_as_translated.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.markPostAsTranslatedRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PostsAPIMovePostFavoritesRequest struct {
	ctx        context.Context
	ApiService *PostsAPIService
	id         int32
	commit     *string
}

// If not set, nothing will happen.
func (r PostsAPIMovePostFavoritesRequest) Commit(commit string) PostsAPIMovePostFavoritesRequest {
	r.commit = &commit
	return r
}

func (r PostsAPIMovePostFavoritesRequest) Execute() (*http.Response, error) {
	return r.ApiService.MovePostFavoritesExecute(r)
}

/*
MovePostFavorites Move Post Favorites

You must have the "Approve Posts" permission. `commit=Submit“ must be set.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the post.
	@return PostsAPIMovePostFavoritesRequest
*/
func (a *PostsAPIService) MovePostFavorites(ctx context.Context, id int32) PostsAPIMovePostFavoritesRequest {
	return PostsAPIMovePostFavoritesRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PostsAPIService) MovePostFavoritesExecute(r PostsAPIMovePostFavoritesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.MovePostFavorites")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/moderator/post/posts/{id}/move_favorites.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.commit == nil {
		return nil, reportError("commit is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "commit", r.commit, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PostsAPIRegeneratePostThumbnailsRequest struct {
	ctx        context.Context
	ApiService *PostsAPIService
	id         int32
}

func (r PostsAPIRegeneratePostThumbnailsRequest) Execute() (*AddFavorite201Response, *http.Response, error) {
	return r.ApiService.RegeneratePostThumbnailsExecute(r)
}

/*
RegeneratePostThumbnails Regenerate Post Thumbnails

You must be Janitor+.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the post.
	@return PostsAPIRegeneratePostThumbnailsRequest
*/
func (a *PostsAPIService) RegeneratePostThumbnails(ctx context.Context, id int32) PostsAPIRegeneratePostThumbnailsRequest {
	return PostsAPIRegeneratePostThumbnailsRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AddFavorite201Response
func (a *PostsAPIService) RegeneratePostThumbnailsExecute(r PostsAPIRegeneratePostThumbnailsRequest) (*AddFavorite201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AddFavorite201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.RegeneratePostThumbnails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/moderator/post/posts/{id}/regenerate_thumbnails.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PostsAPIRegeneratePostVideosRequest struct {
	ctx        context.Context
	ApiService *PostsAPIService
	id         int32
}

func (r PostsAPIRegeneratePostVideosRequest) Execute() (*http.Response, error) {
	return r.ApiService.RegeneratePostVideosExecute(r)
}

/*
RegeneratePostVideos Regenerate Post Videos

You must be Janitor+.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the post.
	@return PostsAPIRegeneratePostVideosRequest
*/
func (a *PostsAPIService) RegeneratePostVideos(ctx context.Context, id int32) PostsAPIRegeneratePostVideosRequest {
	return PostsAPIRegeneratePostVideosRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PostsAPIService) RegeneratePostVideosExecute(r PostsAPIRegeneratePostVideosRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.RegeneratePostVideos")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/moderator/post/posts/{id}/regenerate_videos.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PostsAPIRevertPostRequest struct {
	ctx        context.Context
	ApiService *PostsAPIService
	id         int32
	versionId  *int32
}

// The version ID to revert to.
func (r PostsAPIRevertPostRequest) VersionId(versionId int32) PostsAPIRevertPostRequest {
	r.versionId = &versionId
	return r
}

func (r PostsAPIRevertPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.RevertPostExecute(r)
}

/*
RevertPost Revert Post

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the post.
	@return PostsAPIRevertPostRequest
*/
func (a *PostsAPIService) RevertPost(ctx context.Context, id int32) PostsAPIRevertPostRequest {
	return PostsAPIRevertPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PostsAPIService) RevertPostExecute(r PostsAPIRevertPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.RevertPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/posts/{id}/revert.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.versionId == nil {
		return nil, reportError("versionId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "version_id", r.versionId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PostsAPISearchPostsRequest struct {
	ctx        context.Context
	ApiService *PostsAPIService
	limit      *int32
	page       *int32
	tags       *string
	md5        *string
	random     *string
}

// The maximum number of results to return. Between 0 and 320.
func (r PostsAPISearchPostsRequest) Limit(limit int32) PostsAPISearchPostsRequest {
	r.limit = &limit
	return r
}

// The page number of results to get. Between 1 and 750.
func (r PostsAPISearchPostsRequest) Page(page int32) PostsAPISearchPostsRequest {
	r.page = &page
	return r
}

func (r PostsAPISearchPostsRequest) Tags(tags string) PostsAPISearchPostsRequest {
	r.tags = &tags
	return r
}

func (r PostsAPISearchPostsRequest) Md5(md5 string) PostsAPISearchPostsRequest {
	r.md5 = &md5
	return r
}

func (r PostsAPISearchPostsRequest) Random(random string) PostsAPISearchPostsRequest {
	r.random = &random
	return r
}

func (r PostsAPISearchPostsRequest) Execute() (*ListFavorites200Response, *http.Response, error) {
	return r.ApiService.SearchPostsExecute(r)
}

/*
SearchPosts Search Posts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PostsAPISearchPostsRequest
*/
func (a *PostsAPIService) SearchPosts(ctx context.Context) PostsAPISearchPostsRequest {
	return PostsAPISearchPostsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListFavorites200Response
func (a *PostsAPIService) SearchPostsExecute(r PostsAPISearchPostsRequest) (*ListFavorites200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListFavorites200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.SearchPosts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/posts.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "")
	}
	if r.md5 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "md5", r.md5, "")
	}
	if r.random != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "random", r.random, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PostsAPIUnapprovePostRequest struct {
	ctx        context.Context
	ApiService *PostsAPIService
	postId     *int32
}

func (r PostsAPIUnapprovePostRequest) PostId(postId int32) PostsAPIUnapprovePostRequest {
	r.postId = &postId
	return r
}

func (r PostsAPIUnapprovePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnapprovePostExecute(r)
}

/*
UnapprovePost Unapprove Post

You must have the "Approve Posts" permission. The response does not differ for success or failure.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PostsAPIUnapprovePostRequest
*/
func (a *PostsAPIService) UnapprovePost(ctx context.Context) PostsAPIUnapprovePostRequest {
	return PostsAPIUnapprovePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *PostsAPIService) UnapprovePostExecute(r PostsAPIUnapprovePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.UnapprovePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/moderator/post/approval.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.postId == nil {
		return nil, reportError("postId is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "post_id", r.postId, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PostsAPIUndeletePostRequest struct {
	ctx        context.Context
	ApiService *PostsAPIService
	id         int32
}

func (r PostsAPIUndeletePostRequest) Execute() (*AddFavorite201Response, *http.Response, error) {
	return r.ApiService.UndeletePostExecute(r)
}

/*
UndeletePost Undelete Post

You must have the "Approve Posts" permission.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the post.
	@return PostsAPIUndeletePostRequest
*/
func (a *PostsAPIService) UndeletePost(ctx context.Context, id int32) PostsAPIUndeletePostRequest {
	return PostsAPIUndeletePostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AddFavorite201Response
func (a *PostsAPIService) UndeletePostExecute(r PostsAPIUndeletePostRequest) (*AddFavorite201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AddFavorite201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.UndeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/moderator/post/posts/{id}/undelete.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PostsAPIUnflagPostRequest struct {
	ctx        context.Context
	ApiService *PostsAPIService
	id         int32
	approval   *string
}

// Approves the post if set to \\\&quot;approve\\\&quot;.
func (r PostsAPIUnflagPostRequest) Approval(approval string) PostsAPIUnflagPostRequest {
	r.approval = &approval
	return r
}

func (r PostsAPIUnflagPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnflagPostExecute(r)
}

/*
UnflagPost Unflag Post

You must have the "Approve Posts" permission.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the post.
	@return PostsAPIUnflagPostRequest
*/
func (a *PostsAPIService) UnflagPost(ctx context.Context, id int32) PostsAPIUnflagPostRequest {
	return PostsAPIUnflagPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *PostsAPIService) UnflagPostExecute(r PostsAPIUnflagPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.UnflagPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/posts/{id}/flag.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.approval != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "approval", r.approval, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PostsAPIUpdatePostIqdbRequest struct {
	ctx        context.Context
	ApiService *PostsAPIService
	id         int32
}

func (r PostsAPIUpdatePostIqdbRequest) Execute() (*AddFavorite201Response, *http.Response, error) {
	return r.ApiService.UpdatePostIqdbExecute(r)
}

/*
UpdatePostIqdb Update Post IQDB

You must be Admin+.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the post.
	@return PostsAPIUpdatePostIqdbRequest
*/
func (a *PostsAPIService) UpdatePostIqdb(ctx context.Context, id int32) PostsAPIUpdatePostIqdbRequest {
	return PostsAPIUpdatePostIqdbRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AddFavorite201Response
func (a *PostsAPIService) UpdatePostIqdbExecute(r PostsAPIUpdatePostIqdbRequest) (*AddFavorite201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AddFavorite201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.UpdatePostIqdb")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/posts/{id}/update_iqdb.json"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PostsAPIUploadPostRequest struct {
	ctx                context.Context
	ApiService         *PostsAPIService
	uploadTagString    *string
	uploadRating       *Ratings
	uploadFile         *os.File
	uploadDirectUrl    *string
	uploadSource       *string
	uploadParentId     *int32
	uploadDescription  *string
	uploadAsPending    *bool
	uploadLockedRating *bool
	uploadLockedTags   *string
}

func (r PostsAPIUploadPostRequest) UploadTagString(uploadTagString string) PostsAPIUploadPostRequest {
	r.uploadTagString = &uploadTagString
	return r
}

func (r PostsAPIUploadPostRequest) UploadRating(uploadRating Ratings) PostsAPIUploadPostRequest {
	r.uploadRating = &uploadRating
	return r
}

// Mutually exclusive with direct_url.
func (r PostsAPIUploadPostRequest) UploadFile(uploadFile *os.File) PostsAPIUploadPostRequest {
	r.uploadFile = uploadFile
	return r
}

// Mutually exclusive with file.
func (r PostsAPIUploadPostRequest) UploadDirectUrl(uploadDirectUrl string) PostsAPIUploadPostRequest {
	r.uploadDirectUrl = &uploadDirectUrl
	return r
}

func (r PostsAPIUploadPostRequest) UploadSource(uploadSource string) PostsAPIUploadPostRequest {
	r.uploadSource = &uploadSource
	return r
}

func (r PostsAPIUploadPostRequest) UploadParentId(uploadParentId int32) PostsAPIUploadPostRequest {
	r.uploadParentId = &uploadParentId
	return r
}

func (r PostsAPIUploadPostRequest) UploadDescription(uploadDescription string) PostsAPIUploadPostRequest {
	r.uploadDescription = &uploadDescription
	return r
}

// Must have the \\\&quot;Unrestricted Uploads\\\&quot; permission.
func (r PostsAPIUploadPostRequest) UploadAsPending(uploadAsPending bool) PostsAPIUploadPostRequest {
	r.uploadAsPending = &uploadAsPending
	return r
}

// Must be Privileged+ to use.
func (r PostsAPIUploadPostRequest) UploadLockedRating(uploadLockedRating bool) PostsAPIUploadPostRequest {
	r.uploadLockedRating = &uploadLockedRating
	return r
}

// Must be Admin+ to use.
func (r PostsAPIUploadPostRequest) UploadLockedTags(uploadLockedTags string) PostsAPIUploadPostRequest {
	r.uploadLockedTags = &uploadLockedTags
	return r
}

func (r PostsAPIUploadPostRequest) Execute() (*UploadPost200Response, *http.Response, error) {
	return r.ApiService.UploadPostExecute(r)
}

/*
UploadPost Upload Post

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return PostsAPIUploadPostRequest
*/
func (a *PostsAPIService) UploadPost(ctx context.Context) PostsAPIUploadPostRequest {
	return PostsAPIUploadPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UploadPost200Response
func (a *PostsAPIService) UploadPostExecute(r PostsAPIUploadPostRequest) (*UploadPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UploadPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PostsAPIService.UploadPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uploads.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uploadTagString == nil {
		return localVarReturnValue, nil, reportError("uploadTagString is required and must be specified")
	}
	if r.uploadRating == nil {
		return localVarReturnValue, nil, reportError("uploadRating is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var uploadFileLocalVarFormFileName string
	var uploadFileLocalVarFileName string
	var uploadFileLocalVarFileBytes []byte

	uploadFileLocalVarFormFileName = "upload[file]"
	uploadFileLocalVarFile := r.uploadFile

	if uploadFileLocalVarFile != nil {
		fbs, _ := io.ReadAll(uploadFileLocalVarFile)

		uploadFileLocalVarFileBytes = fbs
		uploadFileLocalVarFileName = uploadFileLocalVarFile.Name()
		uploadFileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: uploadFileLocalVarFileBytes, fileName: uploadFileLocalVarFileName, formFileName: uploadFileLocalVarFormFileName})
	}
	if r.uploadDirectUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[direct_url]", r.uploadDirectUrl, "")
	}
	if r.uploadSource != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[source]", r.uploadSource, "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "upload[tag_string]", r.uploadTagString, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "upload[rating]", r.uploadRating, "")
	if r.uploadParentId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[parent_id]", r.uploadParentId, "")
	}
	if r.uploadDescription != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[description]", r.uploadDescription, "")
	}
	if r.uploadAsPending != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[as_pending]", r.uploadAsPending, "")
	}
	if r.uploadLockedRating != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[locked_rating]", r.uploadLockedRating, "")
	}
	if r.uploadLockedTags != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[locked_tags]", r.uploadLockedTags, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
