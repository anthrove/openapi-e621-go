/*
E621

OpenAPI definition for E621's API. You can find the source [here](https://github.com/DonovanDMC/E621OpenAPI)<br> This document is intended to compliment E621's existing [API Documentation](https://e621.net/help/api).<br> Note if E621's api is under attack and/or cloudflare protections are enabled, the \"Try it out\" buttons here will not work.<br> If they are not working, you can check this [Unofficial Status Page](https://status.e621.ws).

API version: d69c34e
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
)

// UploadsAPIService UploadsAPI service
type UploadsAPIService service

type UploadsAPISearchUploadsRequest struct {
	ctx                 context.Context
	ApiService          *UploadsAPIService
	limit               *int32
	page                *int32
	searchId            *int32
	searchOrder         *string
	searchUploaderId    *float32
	searchUploaderName  *string
	searchSource        *string
	searchSourceMatches *string
	searchRating        *Ratings
	searchParentId      *float32
	searchPostId        *float32
	searchHasPost       *bool
	searchPostTagsMatch *string
	searchStatus        *string
	searchBacktrace     *string
	searchTagString     *string
}

// The maximum number of results to return. Between 0 and 320.
func (r UploadsAPISearchUploadsRequest) Limit(limit int32) UploadsAPISearchUploadsRequest {
	r.limit = &limit
	return r
}

// The page number of results to get. Between 1 and 750.
func (r UploadsAPISearchUploadsRequest) Page(page int32) UploadsAPISearchUploadsRequest {
	r.page = &page
	return r
}

// Search for a specific id.
func (r UploadsAPISearchUploadsRequest) SearchId(searchId int32) UploadsAPISearchUploadsRequest {
	r.searchId = &searchId
	return r
}

func (r UploadsAPISearchUploadsRequest) SearchOrder(searchOrder string) UploadsAPISearchUploadsRequest {
	r.searchOrder = &searchOrder
	return r
}

func (r UploadsAPISearchUploadsRequest) SearchUploaderId(searchUploaderId float32) UploadsAPISearchUploadsRequest {
	r.searchUploaderId = &searchUploaderId
	return r
}

func (r UploadsAPISearchUploadsRequest) SearchUploaderName(searchUploaderName string) UploadsAPISearchUploadsRequest {
	r.searchUploaderName = &searchUploaderName
	return r
}

func (r UploadsAPISearchUploadsRequest) SearchSource(searchSource string) UploadsAPISearchUploadsRequest {
	r.searchSource = &searchSource
	return r
}

func (r UploadsAPISearchUploadsRequest) SearchSourceMatches(searchSourceMatches string) UploadsAPISearchUploadsRequest {
	r.searchSourceMatches = &searchSourceMatches
	return r
}

func (r UploadsAPISearchUploadsRequest) SearchRating(searchRating Ratings) UploadsAPISearchUploadsRequest {
	r.searchRating = &searchRating
	return r
}

func (r UploadsAPISearchUploadsRequest) SearchParentId(searchParentId float32) UploadsAPISearchUploadsRequest {
	r.searchParentId = &searchParentId
	return r
}

func (r UploadsAPISearchUploadsRequest) SearchPostId(searchPostId float32) UploadsAPISearchUploadsRequest {
	r.searchPostId = &searchPostId
	return r
}

func (r UploadsAPISearchUploadsRequest) SearchHasPost(searchHasPost bool) UploadsAPISearchUploadsRequest {
	r.searchHasPost = &searchHasPost
	return r
}

func (r UploadsAPISearchUploadsRequest) SearchPostTagsMatch(searchPostTagsMatch string) UploadsAPISearchUploadsRequest {
	r.searchPostTagsMatch = &searchPostTagsMatch
	return r
}

func (r UploadsAPISearchUploadsRequest) SearchStatus(searchStatus string) UploadsAPISearchUploadsRequest {
	r.searchStatus = &searchStatus
	return r
}

func (r UploadsAPISearchUploadsRequest) SearchBacktrace(searchBacktrace string) UploadsAPISearchUploadsRequest {
	r.searchBacktrace = &searchBacktrace
	return r
}

func (r UploadsAPISearchUploadsRequest) SearchTagString(searchTagString string) UploadsAPISearchUploadsRequest {
	r.searchTagString = &searchTagString
	return r
}

func (r UploadsAPISearchUploadsRequest) Execute() (*SearchUploads200Response, *http.Response, error) {
	return r.ApiService.SearchUploadsExecute(r)
}

/*
SearchUploads Search Uploads

You must be Janitor+. When no results are found, an object with an `uploads` key is returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return UploadsAPISearchUploadsRequest
*/
func (a *UploadsAPIService) SearchUploads(ctx context.Context) UploadsAPISearchUploadsRequest {
	return UploadsAPISearchUploadsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return SearchUploads200Response
func (a *UploadsAPIService) SearchUploadsExecute(r UploadsAPISearchUploadsRequest) (*SearchUploads200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SearchUploads200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsAPIService.SearchUploads")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uploads.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.searchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[id]", r.searchId, "")
	}
	if r.searchOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[order]", r.searchOrder, "")
	}
	if r.searchUploaderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[uploader_id]", r.searchUploaderId, "")
	}
	if r.searchUploaderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[uploader_name]", r.searchUploaderName, "")
	}
	if r.searchSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[source]", r.searchSource, "")
	}
	if r.searchSourceMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[source_matches]", r.searchSourceMatches, "")
	}
	if r.searchRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[rating]", r.searchRating, "")
	}
	if r.searchParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[parent_id]", r.searchParentId, "")
	}
	if r.searchPostId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[post_id]", r.searchPostId, "")
	}
	if r.searchHasPost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[has_post]", r.searchHasPost, "")
	}
	if r.searchPostTagsMatch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[post_tags_match]", r.searchPostTagsMatch, "")
	}
	if r.searchStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[status]", r.searchStatus, "")
	}
	if r.searchBacktrace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[backtrace]", r.searchBacktrace, "")
	}
	if r.searchTagString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[tag_string]", r.searchTagString, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type UploadsAPIUploadPostRequest struct {
	ctx                context.Context
	ApiService         *UploadsAPIService
	uploadTagString    *string
	uploadRating       *Ratings
	uploadFile         *os.File
	uploadDirectUrl    *string
	uploadSource       *string
	uploadParentId     *float32
	uploadDescription  *string
	uploadAsPending    *bool
	uploadLockedRating *bool
	uploadLockedTags   *string
}

func (r UploadsAPIUploadPostRequest) UploadTagString(uploadTagString string) UploadsAPIUploadPostRequest {
	r.uploadTagString = &uploadTagString
	return r
}

func (r UploadsAPIUploadPostRequest) UploadRating(uploadRating Ratings) UploadsAPIUploadPostRequest {
	r.uploadRating = &uploadRating
	return r
}

// Mutually exclusive with direct_url.
func (r UploadsAPIUploadPostRequest) UploadFile(uploadFile *os.File) UploadsAPIUploadPostRequest {
	r.uploadFile = uploadFile
	return r
}

// Mutually exclusive with file.
func (r UploadsAPIUploadPostRequest) UploadDirectUrl(uploadDirectUrl string) UploadsAPIUploadPostRequest {
	r.uploadDirectUrl = &uploadDirectUrl
	return r
}

func (r UploadsAPIUploadPostRequest) UploadSource(uploadSource string) UploadsAPIUploadPostRequest {
	r.uploadSource = &uploadSource
	return r
}

func (r UploadsAPIUploadPostRequest) UploadParentId(uploadParentId float32) UploadsAPIUploadPostRequest {
	r.uploadParentId = &uploadParentId
	return r
}

func (r UploadsAPIUploadPostRequest) UploadDescription(uploadDescription string) UploadsAPIUploadPostRequest {
	r.uploadDescription = &uploadDescription
	return r
}

// Must have the \\\&quot;Unrestricted Uploads\\\&quot; permission.
func (r UploadsAPIUploadPostRequest) UploadAsPending(uploadAsPending bool) UploadsAPIUploadPostRequest {
	r.uploadAsPending = &uploadAsPending
	return r
}

// Must be Privileged+ to use.
func (r UploadsAPIUploadPostRequest) UploadLockedRating(uploadLockedRating bool) UploadsAPIUploadPostRequest {
	r.uploadLockedRating = &uploadLockedRating
	return r
}

// Must be Admin+ to use.
func (r UploadsAPIUploadPostRequest) UploadLockedTags(uploadLockedTags string) UploadsAPIUploadPostRequest {
	r.uploadLockedTags = &uploadLockedTags
	return r
}

func (r UploadsAPIUploadPostRequest) Execute() (*UploadPost200Response, *http.Response, error) {
	return r.ApiService.UploadPostExecute(r)
}

/*
UploadPost Upload Post

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return UploadsAPIUploadPostRequest
*/
func (a *UploadsAPIService) UploadPost(ctx context.Context) UploadsAPIUploadPostRequest {
	return UploadsAPIUploadPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UploadPost200Response
func (a *UploadsAPIService) UploadPostExecute(r UploadsAPIUploadPostRequest) (*UploadPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UploadPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsAPIService.UploadPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uploads.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uploadTagString == nil {
		return localVarReturnValue, nil, reportError("uploadTagString is required and must be specified")
	}
	if r.uploadRating == nil {
		return localVarReturnValue, nil, reportError("uploadRating is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var uploadFileLocalVarFormFileName string
	var uploadFileLocalVarFileName string
	var uploadFileLocalVarFileBytes []byte

	uploadFileLocalVarFormFileName = "upload[file]"
	uploadFileLocalVarFile := r.uploadFile

	if uploadFileLocalVarFile != nil {
		fbs, _ := io.ReadAll(uploadFileLocalVarFile)

		uploadFileLocalVarFileBytes = fbs
		uploadFileLocalVarFileName = uploadFileLocalVarFile.Name()
		uploadFileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: uploadFileLocalVarFileBytes, fileName: uploadFileLocalVarFileName, formFileName: uploadFileLocalVarFormFileName})
	}
	if r.uploadDirectUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[direct_url]", r.uploadDirectUrl, "")
	}
	if r.uploadSource != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[source]", r.uploadSource, "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "upload[tag_string]", r.uploadTagString, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "upload[rating]", r.uploadRating, "")
	if r.uploadParentId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[parent_id]", r.uploadParentId, "")
	}
	if r.uploadDescription != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[description]", r.uploadDescription, "")
	}
	if r.uploadAsPending != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[as_pending]", r.uploadAsPending, "")
	}
	if r.uploadLockedRating != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[locked_rating]", r.uploadLockedRating, "")
	}
	if r.uploadLockedTags != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[locked_tags]", r.uploadLockedTags, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
