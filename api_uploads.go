/*
E621

OpenAPI definition for E621's API. You can find the source [here](https://github.com/DonovanDMC/E621OpenAPI)<br> This document is intended to compliment E621's existing [API Documentation](https://e621.net/help/api).<br> Note if E621's api is under attack and/or cloudflare protections are enabled, the \"Try it out\" buttons here will not work.<br> If they are not working, you can check this [Unofficial Status Page](https://status.e621.ws). 

API version: d69c34e
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi-e621-go

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
)


// UploadsAPIService UploadsAPI service
type UploadsAPIService service

type ApiSearchUploadsRequest struct {
	ctx context.Context
	ApiService *UploadsAPIService
	limit *float32
	page *float32
	searchId *float32
	searchOrder *string
	searchUploaderId *float32
	searchUploaderName *string
	searchSource *string
	searchSourceMatches *string
	searchRating *Ratings
	searchParentId *float32
	searchPostId *float32
	searchHasPost *bool
	searchPostTagsMatch *string
	searchStatus *string
	searchBacktrace *string
	searchTagString *string
}

// The maximum number of results to return. Between 0 and 320.
func (r ApiSearchUploadsRequest) Limit(limit float32) ApiSearchUploadsRequest {
	r.limit = &limit
	return r
}

// The page number of results to get. Between 1 and 750.
func (r ApiSearchUploadsRequest) Page(page float32) ApiSearchUploadsRequest {
	r.page = &page
	return r
}

// Search for a specific id.
func (r ApiSearchUploadsRequest) SearchId(searchId float32) ApiSearchUploadsRequest {
	r.searchId = &searchId
	return r
}

func (r ApiSearchUploadsRequest) SearchOrder(searchOrder string) ApiSearchUploadsRequest {
	r.searchOrder = &searchOrder
	return r
}

func (r ApiSearchUploadsRequest) SearchUploaderId(searchUploaderId float32) ApiSearchUploadsRequest {
	r.searchUploaderId = &searchUploaderId
	return r
}

func (r ApiSearchUploadsRequest) SearchUploaderName(searchUploaderName string) ApiSearchUploadsRequest {
	r.searchUploaderName = &searchUploaderName
	return r
}

func (r ApiSearchUploadsRequest) SearchSource(searchSource string) ApiSearchUploadsRequest {
	r.searchSource = &searchSource
	return r
}

func (r ApiSearchUploadsRequest) SearchSourceMatches(searchSourceMatches string) ApiSearchUploadsRequest {
	r.searchSourceMatches = &searchSourceMatches
	return r
}

func (r ApiSearchUploadsRequest) SearchRating(searchRating Ratings) ApiSearchUploadsRequest {
	r.searchRating = &searchRating
	return r
}

func (r ApiSearchUploadsRequest) SearchParentId(searchParentId float32) ApiSearchUploadsRequest {
	r.searchParentId = &searchParentId
	return r
}

func (r ApiSearchUploadsRequest) SearchPostId(searchPostId float32) ApiSearchUploadsRequest {
	r.searchPostId = &searchPostId
	return r
}

func (r ApiSearchUploadsRequest) SearchHasPost(searchHasPost bool) ApiSearchUploadsRequest {
	r.searchHasPost = &searchHasPost
	return r
}

func (r ApiSearchUploadsRequest) SearchPostTagsMatch(searchPostTagsMatch string) ApiSearchUploadsRequest {
	r.searchPostTagsMatch = &searchPostTagsMatch
	return r
}

func (r ApiSearchUploadsRequest) SearchStatus(searchStatus string) ApiSearchUploadsRequest {
	r.searchStatus = &searchStatus
	return r
}

func (r ApiSearchUploadsRequest) SearchBacktrace(searchBacktrace string) ApiSearchUploadsRequest {
	r.searchBacktrace = &searchBacktrace
	return r
}

func (r ApiSearchUploadsRequest) SearchTagString(searchTagString string) ApiSearchUploadsRequest {
	r.searchTagString = &searchTagString
	return r
}

func (r ApiSearchUploadsRequest) Execute() (*SearchUploads200Response, *http.Response, error) {
	return r.ApiService.SearchUploadsExecute(r)
}

/*
SearchUploads Search Uploads

You must be Janitor+. When no results are found, an object with an `uploads` key is returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchUploadsRequest
*/
func (a *UploadsAPIService) SearchUploads(ctx context.Context) ApiSearchUploadsRequest {
	return ApiSearchUploadsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SearchUploads200Response
func (a *UploadsAPIService) SearchUploadsExecute(r ApiSearchUploadsRequest) (*SearchUploads200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchUploads200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsAPIService.SearchUploads")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uploads.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.searchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[id]", r.searchId, "")
	}
	if r.searchOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[order]", r.searchOrder, "")
	}
	if r.searchUploaderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[uploader_id]", r.searchUploaderId, "")
	}
	if r.searchUploaderName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[uploader_name]", r.searchUploaderName, "")
	}
	if r.searchSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[source]", r.searchSource, "")
	}
	if r.searchSourceMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[source_matches]", r.searchSourceMatches, "")
	}
	if r.searchRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[rating]", r.searchRating, "")
	}
	if r.searchParentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[parent_id]", r.searchParentId, "")
	}
	if r.searchPostId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[post_id]", r.searchPostId, "")
	}
	if r.searchHasPost != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[has_post]", r.searchHasPost, "")
	}
	if r.searchPostTagsMatch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[post_tags_match]", r.searchPostTagsMatch, "")
	}
	if r.searchStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[status]", r.searchStatus, "")
	}
	if r.searchBacktrace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[backtrace]", r.searchBacktrace, "")
	}
	if r.searchTagString != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[tag_string]", r.searchTagString, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadPostRequest struct {
	ctx context.Context
	ApiService *UploadsAPIService
	uploadTagString *string
	uploadRating *Ratings
	uploadFile *os.File
	uploadDirectUrl *string
	uploadSource *string
	uploadParentId *float32
	uploadDescription *string
	uploadAsPending *bool
	uploadLockedRating *bool
	uploadLockedTags *string
}

func (r ApiUploadPostRequest) UploadTagString(uploadTagString string) ApiUploadPostRequest {
	r.uploadTagString = &uploadTagString
	return r
}

func (r ApiUploadPostRequest) UploadRating(uploadRating Ratings) ApiUploadPostRequest {
	r.uploadRating = &uploadRating
	return r
}

// Mutually exclusive with direct_url.
func (r ApiUploadPostRequest) UploadFile(uploadFile *os.File) ApiUploadPostRequest {
	r.uploadFile = uploadFile
	return r
}

// Mutually exclusive with file.
func (r ApiUploadPostRequest) UploadDirectUrl(uploadDirectUrl string) ApiUploadPostRequest {
	r.uploadDirectUrl = &uploadDirectUrl
	return r
}

func (r ApiUploadPostRequest) UploadSource(uploadSource string) ApiUploadPostRequest {
	r.uploadSource = &uploadSource
	return r
}

func (r ApiUploadPostRequest) UploadParentId(uploadParentId float32) ApiUploadPostRequest {
	r.uploadParentId = &uploadParentId
	return r
}

func (r ApiUploadPostRequest) UploadDescription(uploadDescription string) ApiUploadPostRequest {
	r.uploadDescription = &uploadDescription
	return r
}

// Must have the \\\&quot;Unrestricted Uploads\\\&quot; permission.
func (r ApiUploadPostRequest) UploadAsPending(uploadAsPending bool) ApiUploadPostRequest {
	r.uploadAsPending = &uploadAsPending
	return r
}

// Must be Privileged+ to use.
func (r ApiUploadPostRequest) UploadLockedRating(uploadLockedRating bool) ApiUploadPostRequest {
	r.uploadLockedRating = &uploadLockedRating
	return r
}

// Must be Admin+ to use.
func (r ApiUploadPostRequest) UploadLockedTags(uploadLockedTags string) ApiUploadPostRequest {
	r.uploadLockedTags = &uploadLockedTags
	return r
}

func (r ApiUploadPostRequest) Execute() (*UploadPost200Response, *http.Response, error) {
	return r.ApiService.UploadPostExecute(r)
}

/*
UploadPost Upload Post

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUploadPostRequest
*/
func (a *UploadsAPIService) UploadPost(ctx context.Context) ApiUploadPostRequest {
	return ApiUploadPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UploadPost200Response
func (a *UploadsAPIService) UploadPostExecute(r ApiUploadPostRequest) (*UploadPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UploadPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UploadsAPIService.UploadPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uploads.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uploadTagString == nil {
		return localVarReturnValue, nil, reportError("uploadTagString is required and must be specified")
	}
	if r.uploadRating == nil {
		return localVarReturnValue, nil, reportError("uploadRating is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var uploadFileLocalVarFormFileName string
	var uploadFileLocalVarFileName     string
	var uploadFileLocalVarFileBytes    []byte

	uploadFileLocalVarFormFileName = "upload[file]"
	uploadFileLocalVarFile := r.uploadFile

	if uploadFileLocalVarFile != nil {
		fbs, _ := io.ReadAll(uploadFileLocalVarFile)

		uploadFileLocalVarFileBytes = fbs
		uploadFileLocalVarFileName = uploadFileLocalVarFile.Name()
		uploadFileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: uploadFileLocalVarFileBytes, fileName: uploadFileLocalVarFileName, formFileName: uploadFileLocalVarFormFileName})
	}
	if r.uploadDirectUrl != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[direct_url]", r.uploadDirectUrl, "")
	}
	if r.uploadSource != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[source]", r.uploadSource, "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "upload[tag_string]", r.uploadTagString, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "upload[rating]", r.uploadRating, "")
	if r.uploadParentId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[parent_id]", r.uploadParentId, "")
	}
	if r.uploadDescription != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[description]", r.uploadDescription, "")
	}
	if r.uploadAsPending != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[as_pending]", r.uploadAsPending, "")
	}
	if r.uploadLockedRating != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[locked_rating]", r.uploadLockedRating, "")
	}
	if r.uploadLockedTags != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "upload[locked_tags]", r.uploadLockedTags, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 412 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
