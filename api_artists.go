/*
E621

OpenAPI definition for E621's API. You can find the source [here](https://github.com/DonovanDMC/E621OpenAPI)<br> This document is intended to compliment E621's existing [API Documentation](https://e621.net/help/api).<br> Note if E621's api is under attack and/or cloudflare protections are enabled, the \"Try it out\" buttons here will not work.<br> If they are not working, you can check this [Unofficial Status Page](https://status.e621.ws). 

API version: d69c34e
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi-e621-go

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ArtistsAPIService ArtistsAPI service
type ArtistsAPIService service

type ApiCreateArtistRequest struct {
	ctx context.Context
	ApiService *ArtistsAPIService
	artistName *string
	artistOtherNames *[]string
	artistOtherNamesString *string
	artistUrlString *string
	artistNotes *string
	artistGroupName *string
	artistLinkedUserId *float32
	artistIsLocked *bool
}

func (r ApiCreateArtistRequest) ArtistName(artistName string) ApiCreateArtistRequest {
	r.artistName = &artistName
	return r
}

func (r ApiCreateArtistRequest) ArtistOtherNames(artistOtherNames []string) ApiCreateArtistRequest {
	r.artistOtherNames = &artistOtherNames
	return r
}

func (r ApiCreateArtistRequest) ArtistOtherNamesString(artistOtherNamesString string) ApiCreateArtistRequest {
	r.artistOtherNamesString = &artistOtherNamesString
	return r
}

func (r ApiCreateArtistRequest) ArtistUrlString(artistUrlString string) ApiCreateArtistRequest {
	r.artistUrlString = &artistUrlString
	return r
}

func (r ApiCreateArtistRequest) ArtistNotes(artistNotes string) ApiCreateArtistRequest {
	r.artistNotes = &artistNotes
	return r
}

func (r ApiCreateArtistRequest) ArtistGroupName(artistGroupName string) ApiCreateArtistRequest {
	r.artistGroupName = &artistGroupName
	return r
}

// Only usable for Janitor+
func (r ApiCreateArtistRequest) ArtistLinkedUserId(artistLinkedUserId float32) ApiCreateArtistRequest {
	r.artistLinkedUserId = &artistLinkedUserId
	return r
}

// Only usable for Janitor+
func (r ApiCreateArtistRequest) ArtistIsLocked(artistIsLocked bool) ApiCreateArtistRequest {
	r.artistIsLocked = &artistIsLocked
	return r
}

func (r ApiCreateArtistRequest) Execute() (*Artist, *http.Response, error) {
	return r.ApiService.CreateArtistExecute(r)
}

/*
CreateArtist Create Artist

`other_names` & `urls` are silently truncated to 25 entries.
`notes` is silently truncated to the wiki page limit (250,000).
Individual `other_names` are silently truncated to 100 characters.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateArtistRequest
*/
func (a *ArtistsAPIService) CreateArtist(ctx context.Context) ApiCreateArtistRequest {
	return ApiCreateArtistRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Artist
func (a *ArtistsAPIService) CreateArtistExecute(r ApiCreateArtistRequest) (*Artist, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Artist
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtistsAPIService.CreateArtist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/artists.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.artistName == nil {
		return localVarReturnValue, nil, reportError("artistName is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "artist[name]", r.artistName, "")
	if r.artistOtherNames != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "artist[other_names]", r.artistOtherNames, "csv")
	}
	if r.artistOtherNamesString != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "artist[other_names_string]", r.artistOtherNamesString, "")
	}
	if r.artistUrlString != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "artist[url_string]", r.artistUrlString, "")
	}
	if r.artistNotes != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "artist[notes]", r.artistNotes, "")
	}
	if r.artistGroupName != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "artist[group_name]", r.artistGroupName, "")
	}
	if r.artistLinkedUserId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "artist[linked_user_id]", r.artistLinkedUserId, "")
	}
	if r.artistIsLocked != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "artist[is_locked]", r.artistIsLocked, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteArtistRequest struct {
	ctx context.Context
	ApiService *ArtistsAPIService
	idOrName GetArtistIdOrNameParameter
}

func (r ApiDeleteArtistRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteArtistExecute(r)
}

/*
DeleteArtist Delete Artist

You must be an Admin+ to delete an artist.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrName The ID or name of the artist to edit.
 @return ApiDeleteArtistRequest
*/
func (a *ArtistsAPIService) DeleteArtist(ctx context.Context, idOrName GetArtistIdOrNameParameter) ApiDeleteArtistRequest {
	return ApiDeleteArtistRequest{
		ApiService: a,
		ctx: ctx,
		idOrName: idOrName,
	}
}

// Execute executes the request
func (a *ArtistsAPIService) DeleteArtistExecute(r ApiDeleteArtistRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtistsAPIService.DeleteArtist")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/artists/{idOrName}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrName"+"}", url.PathEscape(parameterValueToString(r.idOrName, "idOrName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEditArtistRequest struct {
	ctx context.Context
	ApiService *ArtistsAPIService
	idOrName GetArtistIdOrNameParameter
	editArtistRequest *EditArtistRequest
}

func (r ApiEditArtistRequest) EditArtistRequest(editArtistRequest EditArtistRequest) ApiEditArtistRequest {
	r.editArtistRequest = &editArtistRequest
	return r
}

func (r ApiEditArtistRequest) Execute() (*http.Response, error) {
	return r.ApiService.EditArtistExecute(r)
}

/*
EditArtist Edit Artist

If an artist is locked, you must be Janitor+ to edit them.
`other_names` & `urls` are silently truncated to 25 entries.
`notes` is silently truncated to the wiki page limit (250,000).
Individual `other_names` are silently truncated to 100 characters.
If an artist is on the avoid posting list, you must have the bd staff user flag to edit name, other_names, or group_name.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrName The ID or name of the artist to edit.
 @return ApiEditArtistRequest
*/
func (a *ArtistsAPIService) EditArtist(ctx context.Context, idOrName GetArtistIdOrNameParameter) ApiEditArtistRequest {
	return ApiEditArtistRequest{
		ApiService: a,
		ctx: ctx,
		idOrName: idOrName,
	}
}

// Execute executes the request
func (a *ArtistsAPIService) EditArtistExecute(r ApiEditArtistRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtistsAPIService.EditArtist")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/artists/{idOrName}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrName"+"}", url.PathEscape(parameterValueToString(r.idOrName, "idOrName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/c-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.editArtistRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetArtistRequest struct {
	ctx context.Context
	ApiService *ArtistsAPIService
	idOrName GetArtistIdOrNameParameter
}

func (r ApiGetArtistRequest) Execute() (*GetArtist200Response, *http.Response, error) {
	return r.ApiService.GetArtistExecute(r)
}

/*
GetArtist Get Artist

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrName The ID or name of the artist to get.
 @return ApiGetArtistRequest
*/
func (a *ArtistsAPIService) GetArtist(ctx context.Context, idOrName GetArtistIdOrNameParameter) ApiGetArtistRequest {
	return ApiGetArtistRequest{
		ApiService: a,
		ctx: ctx,
		idOrName: idOrName,
	}
}

// Execute executes the request
//  @return GetArtist200Response
func (a *ArtistsAPIService) GetArtistExecute(r ApiGetArtistRequest) (*GetArtist200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetArtist200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtistsAPIService.GetArtist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/artists/{idOrName}.json"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrName"+"}", url.PathEscape(parameterValueToString(r.idOrName, "idOrName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRevertArtistRequest struct {
	ctx context.Context
	ApiService *ArtistsAPIService
	idOrName GetArtistIdOrNameParameter
	versionId *float32
}

// The version ID to revert to.
func (r ApiRevertArtistRequest) VersionId(versionId float32) ApiRevertArtistRequest {
	r.versionId = &versionId
	return r
}

func (r ApiRevertArtistRequest) Execute() (*http.Response, error) {
	return r.ApiService.RevertArtistExecute(r)
}

/*
RevertArtist Revert Artist

If an artist is locked, you must be Janitor+ to revert them.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param idOrName The ID or name of the artist to revert.
 @return ApiRevertArtistRequest
*/
func (a *ArtistsAPIService) RevertArtist(ctx context.Context, idOrName GetArtistIdOrNameParameter) ApiRevertArtistRequest {
	return ApiRevertArtistRequest{
		ApiService: a,
		ctx: ctx,
		idOrName: idOrName,
	}
}

// Execute executes the request
func (a *ArtistsAPIService) RevertArtistExecute(r ApiRevertArtistRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtistsAPIService.RevertArtist")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/artists/{idOrName}/revert.json"
	localVarPath = strings.Replace(localVarPath, "{"+"idOrName"+"}", url.PathEscape(parameterValueToString(r.idOrName, "idOrName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.versionId == nil {
		return nil, reportError("versionId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "version_id", r.versionId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchArtistsRequest struct {
	ctx context.Context
	ApiService *ArtistsAPIService
	limit *float32
	page *float32
	searchId *float32
	searchOrder *string
	searchName *string
	searchGroupName *string
	searchAnyOtherNameLike *string
	searchAnyNameMatches *string
	searchAnyNameOrUrlMatches *string
	searchUrlMatches *string
	searchCreatorName *string
	searchCreatorId *string
	searchHasTag *string
	searchIsLinked *string
}

// The maximum number of results to return. Between 0 and 320.
func (r ApiSearchArtistsRequest) Limit(limit float32) ApiSearchArtistsRequest {
	r.limit = &limit
	return r
}

// The page number of results to get. Between 1 and 750.
func (r ApiSearchArtistsRequest) Page(page float32) ApiSearchArtistsRequest {
	r.page = &page
	return r
}

// Search for a specific id.
func (r ApiSearchArtistsRequest) SearchId(searchId float32) ApiSearchArtistsRequest {
	r.searchId = &searchId
	return r
}

func (r ApiSearchArtistsRequest) SearchOrder(searchOrder string) ApiSearchArtistsRequest {
	r.searchOrder = &searchOrder
	return r
}

func (r ApiSearchArtistsRequest) SearchName(searchName string) ApiSearchArtistsRequest {
	r.searchName = &searchName
	return r
}

func (r ApiSearchArtistsRequest) SearchGroupName(searchGroupName string) ApiSearchArtistsRequest {
	r.searchGroupName = &searchGroupName
	return r
}

func (r ApiSearchArtistsRequest) SearchAnyOtherNameLike(searchAnyOtherNameLike string) ApiSearchArtistsRequest {
	r.searchAnyOtherNameLike = &searchAnyOtherNameLike
	return r
}

func (r ApiSearchArtistsRequest) SearchAnyNameMatches(searchAnyNameMatches string) ApiSearchArtistsRequest {
	r.searchAnyNameMatches = &searchAnyNameMatches
	return r
}

func (r ApiSearchArtistsRequest) SearchAnyNameOrUrlMatches(searchAnyNameOrUrlMatches string) ApiSearchArtistsRequest {
	r.searchAnyNameOrUrlMatches = &searchAnyNameOrUrlMatches
	return r
}

func (r ApiSearchArtistsRequest) SearchUrlMatches(searchUrlMatches string) ApiSearchArtistsRequest {
	r.searchUrlMatches = &searchUrlMatches
	return r
}

func (r ApiSearchArtistsRequest) SearchCreatorName(searchCreatorName string) ApiSearchArtistsRequest {
	r.searchCreatorName = &searchCreatorName
	return r
}

func (r ApiSearchArtistsRequest) SearchCreatorId(searchCreatorId string) ApiSearchArtistsRequest {
	r.searchCreatorId = &searchCreatorId
	return r
}

func (r ApiSearchArtistsRequest) SearchHasTag(searchHasTag string) ApiSearchArtistsRequest {
	r.searchHasTag = &searchHasTag
	return r
}

func (r ApiSearchArtistsRequest) SearchIsLinked(searchIsLinked string) ApiSearchArtistsRequest {
	r.searchIsLinked = &searchIsLinked
	return r
}

func (r ApiSearchArtistsRequest) Execute() ([]SearchArtists200ResponseInner, *http.Response, error) {
	return r.ApiService.SearchArtistsExecute(r)
}

/*
SearchArtists Search Artists

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchArtistsRequest
*/
func (a *ArtistsAPIService) SearchArtists(ctx context.Context) ApiSearchArtistsRequest {
	return ApiSearchArtistsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SearchArtists200ResponseInner
func (a *ArtistsAPIService) SearchArtistsExecute(r ApiSearchArtistsRequest) ([]SearchArtists200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SearchArtists200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ArtistsAPIService.SearchArtists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/artists.json"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.searchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[id]", r.searchId, "")
	}
	if r.searchOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[order]", r.searchOrder, "")
	}
	if r.searchName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[name]", r.searchName, "")
	}
	if r.searchGroupName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[group_name]", r.searchGroupName, "")
	}
	if r.searchAnyOtherNameLike != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[any_other_name_like]", r.searchAnyOtherNameLike, "")
	}
	if r.searchAnyNameMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[any_name_matches]", r.searchAnyNameMatches, "")
	}
	if r.searchAnyNameOrUrlMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[any_name_or_url_matches]", r.searchAnyNameOrUrlMatches, "")
	}
	if r.searchUrlMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[url_matches]", r.searchUrlMatches, "")
	}
	if r.searchCreatorName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[creator_name]", r.searchCreatorName, "")
	}
	if r.searchCreatorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[creator_id]", r.searchCreatorId, "")
	}
	if r.searchHasTag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[has_tag]", r.searchHasTag, "")
	}
	if r.searchIsLinked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search[is_linked]", r.searchIsLinked, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
